Component: {{component_name}}

I need to adapt this component to my m3-design-v2 design system with PERFECT visual fidelity. I will provide a screenshot and original code. Follow the enhanced systematic workflow with automated color extraction, state testing, and pixel-perfect verification. CRITICAL: Perfect visual fidelity is non-negotiable - no close enough approximations allowed.

CRITICAL SHADOW DOM LIMITATION: Never use @import statements in LitElement static styles. This includes font imports, CSS file imports, or any @import rules. Constructable Stylesheets do not support @import and will cause component registration to fail silently with no error message. Components will appear to build successfully but customElements.get() will return undefined. Always load fonts and external CSS in the consuming page <head> section instead. Add comments in component CSS documenting required fonts.

Phase 1 Color Extraction and Analysis. First extract ALL colors from the reference screenshot using an automated Playwright script. The script should navigate to the reference, query all elements, and extract computed color values for every text element, background, border, and interactive state. Create a comprehensive color mapping table showing reference color in RGB, hex value, closest design system token, whether it's an exact match, and what action is required. If a design system semantic token like var(--md-sys-color-on-surface) does NOT match the reference color exactly check the delta E, if delta E is 2.0 or higher you MUST create component-specific color tokens. Never approximate or use close enough colors. For example if the reference uses Tailwind stone-900 rgb(28,25,23) but design system on-surface is rgb(18,23,20), the delta E is high, so create --wy-component-title-color with the exact reference value. Document why semantic tokens don't work for this specific design. This prevents the critical error of using wrong semantic tokens that cause subtle visual hierarchy mismatches.

Phase 1 continued Analysis and Planning. Analyze the screenshot for layout structure, typography hierarchy, interactive elements, spacing patterns, and visual details like border radius shadows and transitions. Review the original code for hardcoded values to replace. Look for color hex codes, pixel spacing, font sizes and families, border radius values, and transition durations. Create a complete token mapping table. Identify missing design system assets.

Phase 2 Design System Updates. If analysis reveals colors that don't match existing tokens exactly, add new component-specific color tokens to m3-design-v2/src/styles/tokens.css. Follow naming pattern --wy-component-name-property-color. Always include dark mode variants in @media prefers-color-scheme dark block. Add spacing shape or motion tokens if required. Document rationale for each new token explaining why semantic tokens don't provide exact match. Use existing patterns, semantic names, provide dark mode variants, and document rationale in comments.

Phase 3 Implementation. Create Web Component in m3-design-v2/src/components/wy-[name].js using LitElement. Define reactive properties. CRITICAL: DO NOT use @import in Shadow DOM CSS - it causes component registration to fail silently due to Constructable Stylesheets limitations. Fonts must be loaded globally in the consuming page <head> instead. Add comment in component CSS noting required fonts. Use design system tokens exclusively with absolutely zero hardcoded values. Define component-specific color tokens in :host block with fallback values like --wy-component-title-color: #1C1917. Use these specific tokens in styles not generic semantic tokens. Follow Material Design 3 state layer patterns using ::before pseudo-elements with opacity transitions. Add focus-visible outlines 3px solid with 2px offset. Never use !important. Use semantic HTML. Component structure: import from lit, extend LitElement, declare static properties, define static styles with all design system tokens (NO @import statements), add comment at top of styles listing required fonts to load in page head, define component-specific color tokens in :host, implement state layers for interactive elements, implement render method. Font handling: Add comment at top of static styles block listing required fonts. Example: /* Required fonts - load in page <head>: <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet"> */

Phase 4 Build and Prepare Testing. Build design system with npm run build, start dev server with npm run dev, create test page if needed importing tokens and component. CRITICAL: Test page must load all required fonts in <head> section. Material Symbols must be loaded globally for icon rendering with <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet">. DM Sans and Playfair Display should be loaded via tokens.css @import or direct <link> tags. Verify fonts load before testing component to avoid false negatives.

Phase 5.1 Color Accuracy Testing MANDATORY. Create and run test-color-accuracy.py script. Extract reference colors from original using Playwright script that loads reference and extracts computed getComputedStyle values for all text backgrounds and borders converting to RGB tuples. Define REFERENCE_COLORS dictionary with element name to RGB tuple mapping like title: (28, 25, 23) for stone-900. Extract implementation colors using same method from component shadow root. Calculate color delta using Euclidean distance formula. For each color verify delta E is less than 2.0 which means imperceptible difference. Delta E between 2.0 and 5.0 is noticeable, above 5.0 is clearly visible. Print formatted table showing element, actual RGB, expected RGB, and delta value. Success criteria: ALL colors must have delta E less than 2.0. If test fails identify which colors have high delta, verify component uses correct component-specific tokens not generic semantic tokens, ensure tokens defined in :host block for Shadow DOM, re-run extraction to verify reference colors, update token values. Common failures: using var(--md-sys-color-on-surface) when reference uses Tailwind stone palette, tokens not cascading into Shadow DOM, circular variable references like --spacing-sm: var(--spacing-sm, ...), CDN cache serving old bundle.

Phase 5.2 Interactive State Testing MANDATORY. Extract state colors from reference for hover focus active and disabled states using Playwright to hover elements, press Tab for focus, click for active. For each interactive element verify default rest state colors match reference exactly with delta E less than 2.0, hover state border background color changes match, focus state keyboard indicator matches with outline style color width and offset, active pressed state click appearance matches, disabled state opacity cursor and colors match if applicable, loading state indicators match if applicable, error state styling matches if applicable, and state transitions animation duration and easing match reference. Test all interactive states for buttons chips links form inputs. Success criteria: all state colors match reference with delta E less than 2.0, state transitions occur, no states missing, focus indicators meet WCAG. Common issues: using :hover without state layer pseudo-element, missing :focus-visible styles, hardcoding state colors instead of state layer opacity, missing disabled state, transitions too fast or slow.

Phase 5.3 Pixel Perfect Visual Comparison MANDATORY. Use Playwright plus PIL to capture screenshots from reference and implementation at exact same viewport like 1200x900. Convert images to RGB numpy arrays. Calculate per-pixel difference using absolute value of array subtraction. Create diff heatmap where pixels within tolerance of 2 RGB points per channel are green and pixels outside tolerance are red. Calculate match percentage as matching pixels divided by total pixels times 100. Generate visual outputs: diff heatmap PNG with green for matching red for different, side-by-side comparison PNG with reference on left implementation on right with labels. Success criteria: match percentage must be 99.9% or higher allowing only 0.1% for anti-aliasing differences, no visible differences in side-by-side, diff heatmap shows only minor anti-aliasing if any. Acceptable differences: font rendering 1-2px due to browser OS, anti-aliasing on rounded corners within tolerance, sub-pixel rendering under 2 points per channel. Unacceptable: wrong colors different hue saturation lightness, wrong spacing margin padding gap offsets, wrong font sizes or weights, wrong border radius or shapes, missing elements or incorrect positioning. If match under 99.9%: review heatmap to identify problem areas, check if acceptable anti-aliasing or real issues, increase tolerance slightly if only anti-aliasing max 5, if real differences fix implementation and retest, never lower success threshold.

Phase 5.4 Functional Testing. Verify all original functionality preserved, test modal open close, click handlers, navigation, keyboard shortcuts, event dispatching, state management. Run automated functional test or manual verification.

Phase 5.5 Design System Compliance. Scan component code for hardcoded hex codes, magic number spacing, arbitrary durations, !important declarations. Verify 100% token usage. Zero hardcoded values allowed.

Phase 6 Deliverables. Provide: 1 Color extraction report table showing reference RGB, hex value, design system token, whether exact match, and action taken. 2 Token mapping report complete table original value to token with status. 3 Color accuracy test results showing all delta E values under 2.0 with formatted table and max delta reported. 4 Interactive state test results showing all states verified with hover focus active disabled tested and screenshot evidence. 5 Pixel perfect comparison results with match percentage 99.9% or higher, diff heatmap image path, side-by-side comparison image path, and acceptable vs unacceptable differences documented. 6 Complete component code with full Web Component implementation, registration in src/main.js AND src/web-components.js (CDN bundle entry point), component.json entry with props and examples, usage example in markup, font loading requirements documented in component comments. 7 Design system updates if any showing new tokens added to tokens.css, dark mode variants, and rationale for why semantic tokens didn't work. 8 Integration instructions for using component, available API, event listeners, build and deploy commands. 9 Component registration verification: After building, test that customElements.get('wy-component-name') returns the constructor function (not undefined). This confirms no @import errors prevented registration. If undefined, check for @import statements in component CSS and verify component is imported in both main.js and web-components.js.

Success criteria ALL must pass: Color accuracy with all elements delta E under 2.0 imperceptible difference, pixel match with 99.9% or higher match percentage, all interactive states tested and verified matching reference, visual fidelity where component matches screenshot exactly, token usage 100% design tokens zero hardcoded values, Playwright tests all passing, dark mode works in both schemes, no console errors, semantic HTML, ARIA labels present, focus states visible and accessible.

ZERO-TRUST VERIFICATION REQUIRED: Never report implementation as complete without rigorous verification. Test must verify actual computed styles not just DOM presence. Check alignment by measuring paddingLeft of all elements must match exactly within 1px tolerance. Verify visibility with dimensions greater than zero opacity not zero z-index makes sense. Check design token resolution by getting CSS variable values not just that var() is used. Verify no console errors warnings or 404s excluding favicon. Check layout integrity with scrollWidth equals clientWidth no overflow. Implement cache busting in all verification URLs with timestamp query param. Document what cannot be verified programmatically and provide specific manual verification instructions with exact steps. Report failures immediately do not claim success when tests fail.

Anti-patterns to avoid: hardcoded colors hex rgb rgba, magic number spacing, arbitrary transitions, !important declarations, changing background-color on hover directly, hardcoded border-radius, skipping dark mode testing, using @import for fonts in Shadow DOM (causes registration failure), forgetting to load fonts globally in page head, inline styles for theming, delivering without verification, using generic semantic tokens when reference needs specific colors, assuming semantic token names match without verifying RGB values, testing functionality before colors are correct, approximating colors instead of exact match.

Design system compliance for colors: use var(--md-sys-color-*) or var(--wy-*), provide dark mode variants, use color-mix() for transparency. Typography: use var(--font-serif) var(--font-sans) var(--font-display), clamp() for fluid scaling, design system letter spacing. Spacing: use var(--spacing-*) xxs through 3xl, follow 8px grid, clamp() for responsive. Shape: use var(--md-sys-shape-corner-*), corner-full for capsules. Motion: use var(--md-sys-motion-duration-*) and var(--md-sys-motion-easing-*), no magic durations. Interactive states: hover with ::before overlay, opacity var(--md-sys-state-hover-opacity), focus 3px outline 2px offset, never change background directly.

Execute complete workflow with all testing phases 5.1 through 5.5 and provide all 8 deliverables with color extraction report, color accuracy delta E results, state testing results, pixel perfect comparison with heatmap and match percentage, complete code, design system updates, and integration instructions.
