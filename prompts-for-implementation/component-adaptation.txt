Component: {{component_name}}

I need to adapt this component to my m3-design-v2 design system with PERFECT visual fidelity. I will provide a screenshot and original code. Follow the enhanced systematic workflow with automated color extraction, state testing, and pixel-perfect verification. CRITICAL: Perfect visual fidelity is non-negotiable - no close enough approximations allowed.

CRITICAL SHADOW DOM LIMITATION: Never use @import statements in LitElement static styles. This includes font imports, CSS file imports, or any @import rules. Constructable Stylesheets do not support @import and will cause component registration to fail silently with no error message. Components will appear to build successfully but customElements.get() will return undefined. Always load fonts and external CSS in the consuming page <head> section instead. Add comments in component CSS documenting required fonts.

Phase 1 Color Extraction and Analysis. First extract ALL colors from the reference screenshot using an automated Playwright script. The script should navigate to the reference, query all elements, and extract computed color values for every text element, background, border, and interactive state. Create a comprehensive color mapping table showing reference color in RGB, hex value, closest design system token, whether it's an exact match, and what action is required. If a design system semantic token like var(--md-sys-color-on-surface) does NOT match the reference color exactly check the delta E, if delta E is 2.0 or higher you MUST create component-specific color tokens. Never approximate or use close enough colors. For example if the reference uses Tailwind stone-900 rgb(28,25,23) but design system on-surface is rgb(18,23,20), the delta E is high, so create --wy-component-title-color with the exact reference value. Document why semantic tokens don't work for this specific design. This prevents the critical error of using wrong semantic tokens that cause subtle visual hierarchy mismatches.

Phase 1 continued Analysis and Planning. Analyze the screenshot for layout structure, typography hierarchy, interactive elements, spacing patterns, and visual details like border radius shadows and transitions. Review the original code for hardcoded values to replace. Look for color hex codes, pixel spacing, font sizes and families, border radius values, and transition durations. Create a complete token mapping table. Identify missing design system assets.

Phase 2 Design System Updates. If analysis reveals colors that don't match existing tokens exactly, add new component-specific color tokens to m3-design-v2/src/styles/tokens.css. Follow naming pattern --wy-component-name-property-color. Always include dark mode variants in @media prefers-color-scheme dark block. Add spacing shape or motion tokens if required. Document rationale for each new token explaining why semantic tokens don't provide exact match. Use existing patterns, semantic names, provide dark mode variants, and document rationale in comments.

Phase 3 Implementation. Create Web Component in m3-design-v2/src/components/wy-[name].js using LitElement. Define reactive properties. CRITICAL: DO NOT use @import in Shadow DOM CSS - it causes component registration to fail silently due to Constructable Stylesheets limitations. Fonts must be loaded globally in the consuming page <head> instead. Add comment in component CSS noting required fonts. Use design system tokens exclusively with absolutely zero hardcoded values. Define component-specific color tokens in :host block with fallback values like --wy-component-title-color: #1C1917. Use these specific tokens in styles not generic semantic tokens. Follow Material Design 3 state layer patterns using ::before pseudo-elements with opacity transitions. Add focus-visible outlines 3px solid with 2px offset. Never use !important. Use semantic HTML. Component structure: import from lit, extend LitElement, declare static properties, define static styles with all design system tokens (NO @import statements), add comment at top of styles listing required fonts to load in page head, define component-specific color tokens in :host, implement state layers for interactive elements, implement render method. Font handling: Add comment at top of static styles block listing required fonts. Example: /* Required fonts - load in page <head>: <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet"> */

Phase 4 Build and Prepare Testing. Build design system with npm run build, start dev server with npm run dev, create test page if needed importing tokens and component. CRITICAL: Test page must load all required fonts in <head> section. Material Symbols must be loaded globally for icon rendering with <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet">. DM Sans and Playfair Display should be loaded via tokens.css @import or direct <link> tags. Verify fonts load before testing component to avoid false negatives.

Phase 5.1 Color Accuracy Testing MANDATORY. Create and run test-color-accuracy.py script. Extract reference colors from original using Playwright script that loads reference and extracts computed getComputedStyle values for all text backgrounds and borders converting to RGB tuples. Define REFERENCE_COLORS dictionary with element name to RGB tuple mapping like title: (28, 25, 23) for stone-900. Extract implementation colors using same method from component shadow root. Calculate color delta using Euclidean distance formula. For each color verify delta E is less than 2.0 which means imperceptible difference. Delta E between 2.0 and 5.0 is noticeable, above 5.0 is clearly visible. Print formatted table showing element, actual RGB, expected RGB, and delta value. Success criteria: ALL colors must have delta E less than 2.0. If test fails identify which colors have high delta, verify component uses correct component-specific tokens not generic semantic tokens, ensure tokens defined in :host block for Shadow DOM, re-run extraction to verify reference colors, update token values. Common failures: using var(--md-sys-color-on-surface) when reference uses Tailwind stone palette, tokens not cascading into Shadow DOM, circular variable references like --spacing-sm: var(--spacing-sm, ...), CDN cache serving old bundle.

Phase 5.2 Interactive State Testing MANDATORY. Extract state colors from reference for hover focus active and disabled states using Playwright to hover elements, press Tab for focus, click for active. For each interactive element verify default rest state colors match reference exactly with delta E less than 2.0, hover state border background color changes match, focus state keyboard indicator matches with outline style color width and offset, active pressed state click appearance matches, disabled state opacity cursor and colors match if applicable, loading state indicators match if applicable, error state styling matches if applicable, and state transitions animation duration and easing match reference. Test all interactive states for buttons chips links form inputs. Success criteria: all state colors match reference with delta E less than 2.0, state transitions occur, no states missing, focus indicators meet WCAG. Common issues: using :hover without state layer pseudo-element, missing :focus-visible styles, hardcoding state colors instead of state layer opacity, missing disabled state, transitions too fast or slow.

Phase 5.3 Pixel Perfect Visual Comparison MANDATORY. Use Playwright plus PIL to capture screenshots from reference and implementation at exact same viewport like 1200x900. Convert images to RGB numpy arrays. Calculate per-pixel difference using absolute value of array subtraction. Create diff heatmap where pixels within tolerance of 2 RGB points per channel are green and pixels outside tolerance are red. Calculate match percentage as matching pixels divided by total pixels times 100. Generate visual outputs: diff heatmap PNG with green for matching red for different, side-by-side comparison PNG with reference on left implementation on right with labels. Success criteria: match percentage must be 99.9% or higher allowing only 0.1% for anti-aliasing differences, no visible differences in side-by-side, diff heatmap shows only minor anti-aliasing if any. Acceptable differences: font rendering 1-2px due to browser OS, anti-aliasing on rounded corners within tolerance, sub-pixel rendering under 2 points per channel. Unacceptable: wrong colors different hue saturation lightness, wrong spacing margin padding gap offsets, wrong font sizes or weights, wrong border radius or shapes, missing elements or incorrect positioning. If match under 99.9%: review heatmap to identify problem areas, check if acceptable anti-aliasing or real issues, increase tolerance slightly if only anti-aliasing max 5, if real differences fix implementation and retest, never lower success threshold.

Phase 5.4 Functional Testing. Verify all original functionality preserved, test modal open close, click handlers, navigation, keyboard shortcuts, event dispatching, state management. Run automated functional test or manual verification.

Phase 5.5 Design System Compliance. Scan component code for hardcoded hex codes, magic number spacing, arbitrary durations, !important declarations. Verify 100% token usage. Zero hardcoded values allowed.

Phase 5.6 Three-Level CSS Variable Verification MANDATORY. For components with variants or themeable properties verify CSS variables resolve correctly at all three levels. Level 1 Root: Check getComputedStyle(document.documentElement).getPropertyValue() shows default value defined in :root. Level 2 Component: Check getComputedStyle(component).getPropertyValue() shows overridden value if variant or attribute applied via :host([variant]) selector. Level 3 Actual Computed: Check getComputedStyle(shadowElement).backgroundColor matches expected final value. Verify variant overrides work by comparing Level 1 to Level 2 must be different when variant applied. Document all three levels in test report to explain why DevTools shows different values at different inspection points. Common failure: Level 2 equals Level 1 when override should be active indicates :host selector not working.

Phase 5.7 Font Loading Verification MANDATORY. Verify fonts actually loaded not using fallback. Check getComputedStyle(element).fontFamily contains expected font name like DM Sans or Material Symbols Outlined not generic sans-serif or serif. Test label text and icon elements. If font family shows fallback this indicates font not loaded in page head or @import error in Shadow DOM. Failure criteria: any element using fallback font equals FAIL.

Phase 5.8 Border Visibility Verification MANDATORY. For elements with borders verify borderWidth not 0px and borderStyle not none. Check getComputedStyle(element).borderWidth and borderStyle. If border intended but shows 0px or none this indicates CSS not applying or specificity issue. Verify border color has adequate contrast with background.

Phase 5.9 Interactive State Change Verification MANDATORY. Do not just check hover styles exist. Actually trigger hover with element.dispatchEvent(new MouseEvent('mouseenter')) then measure getComputedStyle() before and after. Verify values actually change not just that :hover selector exists. Check border color background color or opacity changes. For state layers verify ::before pseudo-element opacity increases on hover. Test focus with element.focus() then verify outline appears with correct width color offset. Test that state changes are measurable not assumed. Common failure: hover styles defined but dont actually apply computed values identical before and after.

Phase 5.10 Event and Reactivity Verification MANDATORY. Verify component events actually fire not just that addEventListener exists. Add event listener then trigger action programmatically measure that event fired and event.detail contains correct data. Verify property changes cause re-render by setting component.property to new value then checking DOM updates. Test disabled state actually prevents interaction not just changes opacity. Verify keyboard events like Enter Escape Arrow keys trigger correct handlers. Common failure: events defined but never fire or detail object incorrect structure.

Phase 5.11 ARIA and Accessibility Verification MANDATORY. Check all interactive elements have required ARIA attributes. Verify aria-haspopup aria-expanded aria-label aria-selected on appropriate elements using element.hasAttribute() and element.getAttribute(). Check role attributes present where required. Verify focus indicators visible with outline width greater than 0. Test keyboard navigation actually works not just that handlers exist. Tab through elements verify focus visible on each. Common failure: ARIA attributes missing or incorrect values like aria-expanded always true.

Phase 6 Deliverables. Provide: 1 Color extraction report table showing reference RGB, hex value, design system token, whether exact match, and action taken. 2 Token mapping report complete table original value to token with status. 3 Color accuracy test results showing all delta E values under 2.0 with formatted table and max delta reported. 4 Interactive state test results showing all states verified with hover focus active disabled tested and screenshot evidence. 5 Pixel perfect comparison results with match percentage 99.9% or higher, diff heatmap image path, side-by-side comparison image path, and acceptable vs unacceptable differences documented. 6 Complete component code with full Web Component implementation, registration in src/main.js AND src/web-components.js (CDN bundle entry point), component.json entry with props and examples, usage example in markup, font loading requirements documented in component comments. 7 Design system updates if any showing new tokens added to tokens.css, dark mode variants, and rationale for why semantic tokens didn't work. 8 Integration instructions for using component, available API, event listeners, build and deploy commands. 9 Component registration verification: After building, test that customElements.get('wy-component-name') returns the constructor function (not undefined). This confirms no @import errors prevented registration. If undefined, check for @import statements in component CSS and verify component is imported in both main.js and web-components.js. 10 Comprehensive Zero-Trust verification report showing: console hygiene zero errors, component registration verified, padding alignment all elements within 1px, dropdown quality dimensions options icon font, info panel visibility dimensions content, design token three-level resolution root component actual, font loading no fallbacks, border visibility width greater than 0, layout overflow none, interactive state changes measured before after, ARIA attributes complete, event firing with correct detail, manual verification instructions specific. Include actual measured values not just PASS FAIL. Document test execution with cache-busted URL timestamp. Report honest status if any test fails do not claim complete.

Phase 6.1 Manual Verification Documentation MANDATORY. For every aspect that cannot be verified programmatically provide specific step-by-step instructions. Include exact URLs with hard refresh requirement. Specify which element to inspect and which computed style property to check. Give expected values with acceptable tolerance. Provide screenshots showing what to look for. Examples: Please visually confirm dropdown menu background is rgb(253, 251, 247) when menu is open by right-clicking menu inspecting in DevTools Computed tab finding background-color. Please measure gap between elements using DevTools ruler tool verify 16px plus-minus 1px tolerance. Please draw vertical alignment guide in DevTools verify all elements align within 1px. Be exhaustively specific about manual checks.

Success criteria ALL must pass: Color accuracy with all elements delta E under 2.0 imperceptible difference, pixel match with 99.9% or higher match percentage, all interactive states tested and verified matching reference, visual fidelity where component matches screenshot exactly, token usage 100% design tokens zero hardcoded values, Playwright tests all passing, dark mode works in both schemes, no console errors, semantic HTML, ARIA labels present, focus states visible and accessible. Three-level CSS variable resolution verified root component actual. Fonts loaded no fallbacks checked with getComputedStyle fontFamily. Borders visible width greater than 0 checked. Interactive states actually change measured before after not assumed. Events fire with correct detail verified. Property changes cause re-render tested. Padding alignment within 1px all elements measured. Layout no overflow scrollWidth equals clientWidth. Component registration returns constructor not undefined. Zero tolerance for console errors warnings or 404s. Cache-busted verification URLs used. Manual verification instructions provided for aspects that cannot be programmatically verified.

ZERO-TRUST VERIFICATION REQUIRED: Never report implementation as complete without rigorous verification. DOM element presence is meaningless without quality verification.

Mandatory Verification Protocol:
1. Visual Verification via Computed Styles: Do NOT just check if element exists. Use window.getComputedStyle() for actual rendered values. Verify alignment by measuring paddingLeft paddingRight marginLeft of ALL elements in the component must match within 1px tolerance. Verify visibility with offsetWidth and offsetHeight greater than zero, display not none, opacity greater than zero, z-index makes sense for stacking. Check for obscured elements or layout issues with scrollWidth equals clientWidth and scrollHeight equals clientHeight no overflow.

2. Design System Integrity: Verify colors match specific design tokens by comparing actual hex values from getComputedStyle().backgroundColor against expected token values not just that var() is used. Check fonts resolve to correct family not fallback by inspecting getComputedStyle().fontFamily. Verify spacing uses exact design system values like 24px equals var(--spacing-lg) not 2rem or other arbitrary values. Compare computed values to expected token resolution. Verify no circular references or undefined token values.

3. Infrastructure and State: Implement cache busting in ALL verification URLs with timestamp query param like url?v=timestamp. Capture and verify zero console errors warnings or 404s excluding favicon. Any console error equals immediate FAIL. Check loading states spinner visibility if applicable. Verify network requests succeed.

4. Interactive State Quality: For hover focus active disabled states verify with Playwright hover() and keyboard.press() then check getComputedStyle() values match reference. Verify state layer opacity transitions occur. Check focus outlines visible with correct width offset color. Test keyboard navigation arrow keys enter escape. Verify event handlers fire with correct event.detail values.

5. Component Integration: After building verify customElements.get('wy-component-name') returns constructor function not undefined. If undefined registration failed check for @import errors. Verify component imported in both main.js AND web-components.js. Test component renders in consuming page with proper Shadow DOM styles applied.

Failure Criteria STRICT:
- ANY console error or warning (except favicon 404) = FAIL immediately
- Padding alignment off by more than 1px = FAIL
- Element present but width or height equals 0 = FAIL  
- Design token resolves to wrong value = FAIL
- Layout overflow scrollWidth greater than clientWidth = FAIL
- Component registration returns undefined = FAIL
- Missing interactive state styling = FAIL
- Console shows wrong color in getComputedStyle = FAIL

Test Result Standards:
- PASS requires: All computed styles match expected exactly, alignment verified via pixel measurements, zero console errors, all design tokens resolve correctly, no layout overflow, dimensions greater than zero, proper visibility.
- PARTIAL requires manual verification: Provide specific step-by-step instructions for what user must manually verify like dropdown menu background color when open or animation smoothness or visual contrast perception. Be explicit about what to check and how.
- FAIL includes: Element exists but not visible, wrong styles applied computed values dont match expected, console errors present, padding alignment off, token resolution incorrect, registration failed.

Documentation Requirements:
- Create detailed Zero-Trust verification report showing all test results with actual computed values measured.
- Document PASS FAIL or MANUAL for each verification check.
- For manual checks provide exact steps like open URL hard refresh click element X measure computed style Y verify value Z.
- Report failures immediately with root cause analysis do not claim success when tests fail.
- Include retest protocol for after deployment.

Execute verification with cache-busted URLs. Measure actual computed styles. Report honest status. Document manual verification steps. Only claim complete when ALL tests pass.

Anti-patterns to avoid: hardcoded colors hex rgb rgba, magic number spacing, arbitrary transitions, !important declarations, changing background-color on hover directly, hardcoded border-radius, skipping dark mode testing, using @import for fonts in Shadow DOM (causes registration failure), forgetting to load fonts globally in page head, inline styles for theming, delivering without verification, using generic semantic tokens when reference needs specific colors, assuming semantic token names match without verifying RGB values, testing functionality before colors are correct, approximating colors instead of exact match, checking only DOM presence not computed styles, claiming PASS when tests actually FAIL, shallow verification that misses implementation bugs, not verifying three-level CSS variable resolution, assuming hover works without measuring state changes, not testing events actually fire, forgetting to verify fonts loaded not fallback, not checking borders have width greater than 0, assuming padding aligned without measuring, not verifying variant overrides actually apply, skipping ARIA attribute verification, not testing keyboard navigation, claiming complete without manual verification instructions, using cached URLs in verification, reporting success prematurely without rigorous testing.

Design system compliance for colors: use var(--md-sys-color-*) or var(--wy-*), provide dark mode variants, use color-mix() for transparency. Typography: use var(--font-serif) var(--font-sans) var(--font-display), clamp() for fluid scaling, design system letter spacing. Spacing: use var(--spacing-*) xxs through 3xl, follow 8px grid, clamp() for responsive. Shape: use var(--md-sys-shape-corner-*), corner-full for capsules. Motion: use var(--md-sys-motion-duration-*) and var(--md-sys-motion-easing-*), no magic durations. Interactive states: hover with ::before overlay, opacity var(--md-sys-state-hover-opacity), focus 3px outline 2px offset, never change background directly.

Execute complete workflow with all testing phases 5.1 through 5.5 and provide all 8 deliverables with color extraction report, color accuracy delta E results, state testing results, pixel perfect comparison with heatmap and match percentage, complete code, design system updates, and integration instructions.
